<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Mapping Tool</title>
    <link rel="stylesheet" href="custom.css">
    <style>
        .parent-node-select-row {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }
        .status-message {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 12px 16px;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }
        .status-message.success {
            background: #28a745;
        }
        .status-message.error {
            background: #dc3545;
        }
        .status-message.show {
            opacity: 1;
            transform: translateY(0);
        }
        .map-selector {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
            background: #f8f9fa;
        }
        body.dark .map-selector {
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }
        .map-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            background: white;
            font-size: 14px;
            margin-bottom: 8px;
        }
        body.dark .map-select {
            background: #262626;
            border: 1px solid #404040;
            color: #e5e5e5;
        }
        .map-actions {
            display: flex;
            gap: 8px;
        }
        .map-action-btn {
            padding: 6px 12px;
            font-size: 12px;
            border: 1px solid #e5e5e5;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .map-action-btn:hover {
            background: #f5f5f5;
        }
        body.dark .map-action-btn {
            background: #262626;
            border: 1px solid #404040;
            color: #e5e5e5;
        }
        body.dark .map-action-btn:hover {
            background: #333;
        }
    </style>
</head>
<body>
    <!-- Status Message -->
    <div id="statusMessage" class="status-message"></div>

    <!-- Top Bar -->
    <div class="top-bar">
        <div class="logo-section">
            <div class="logo">S</div>
            <div class="project-name">System Map</div>
        </div>
        
        <div class="top-actions">
            <button class="action-btn" onclick="exportMap()">Export</button>
            <button class="action-btn" onclick="shareMap()">Share</button>
            <button class="action-btn" onclick="saveMap()">Save</button>
            <button class="theme-toggle" onclick="toggleTheme()">🌙</button>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="main-layout">
        <!-- Side Panel -->
        <div class="side-panel" id="sidePanel">
            <button class="expand-btn" onclick="togglePanel()">›</button>
            
            <!-- Map Selector -->
            <div class="map-selector">
                <select class="map-select" id="mapSelector" onchange="loadSelectedMap()">
                    <option value="">Loading maps...</option>
                </select>
                <div class="map-actions">
                    <button class="map-action-btn" onclick="createNewMap()">New Map</button>
                    <button class="map-action-btn" onclick="deleteCurrentMap()">Delete</button>
                </div>
            </div>
            
            <div class="panel-header">
                <div class="panel-title">Tools</div>
                <button class="collapse-btn" onclick="togglePanel()">‹</button>
            </div>
            
            <div class="panel-content">
                <div class="tool-section">
                    <h3>Add Nodes</h3>
                    <div class="tool-item" onclick="selectTool('node')">
                        <div class="tool-icon"></div>
                        <div class="tool-text">Node</div>
                    </div>
                    <div class="tool-item" onclick="selectTool('edit')">
                        <div class="tool-icon"></div>
                        <div class="tool-text">Edit Node</div>
                    </div>
                </div>

                <!-- Add Node Configuration Section -->
                <div class="node-config" id="nodeConfig">
                    <div class="config-field">
                        <label class="config-label">Name</label>
                        <input type="text" class="config-input" id="nodeName" placeholder="Enter node name">
                    </div>
                    
                    <div class="config-field">
                        <label class="config-label">Type</label>
                        <input type="text" class="config-input" id="nodeType" list="nodeTypeOptions" placeholder="Select or enter type">
                        <datalist id="nodeTypeOptions">
                            <option value="Hardware">
                            <option value="Software">
                            <option value="Service">
                            <option value="Network">
                            <option value="Storage">
                            <option value="Database">
                            <option value="External">
                            <option value="API">
                            <option value="Cache">
                            <option value="Queue">
                            <option value="Monitor">
                            <option value="Security">
                        </datalist>
                    </div>
                    
                    <!-- Parent Node Select -->
                    <div class="config-field">
                        <label class="config-label">Parent Node</label>
                        <div class="parent-node-row">
                            <div id="parentNodeContainer">
                                <div class="parent-node-select-row">
                                    <select class="config-select parent-node-select">
                                        <option value="">Select parent node</option>
                                        <!-- Dynamically populated -->
                                    </select>
                                </div>
                                <!-- Additional parent selects will be added here dynamically -->
                            </div>
                            <button class="add-parent-btn add-attribute-btn" type="button" onclick="addParentNodeSelect()">+</button>
                        </div>
                    </div>

                    <!-- Custom Attributes Section -->
                    <div class="custom-attributes">
                        <div class="attributes-header">
                            <span class="attributes-title">Custom Attributes</span>
                        </div>
                        <div id="attributesList">
                            <!-- Dynamic attributes will be added here -->
                        </div>
                        <button class="add-attribute-btn" onclick="addAttribute()">+</button>
                    </div>

                    <!-- Save Button -->
                    <button class="save-node-btn" onclick="saveNode()">Save Node</button>
                </div>

                <!-- Edit Node Configuration Section -->
                <div class="edit-node-config" id="editNodeConfig">
                    <div class="config-field">
                        <label class="config-label">Select Node</label>
                        <select class="config-select" id="editNodeSelect" onchange="populateEditNodeForm()">
                            <option value="">Select node</option>
                            <!-- Dynamically populated -->
                        </select>
                    </div>

                    <!-- Edit form - only shown when a node is selected -->
                    <div id="editNodeForm" style="display: none;">
                        <div class="config-field">
                            <label class="config-label">Name</label>
                            <input type="text" class="config-input" id="editNodeName" placeholder="Enter node name">
                        </div>
                        
                        <div class="config-field">
                            <label class="config-label">Type</label>
                            <input type="text" class="config-input" id="editNodeType" list="editNodeTypeOptions" placeholder="Select or enter type">
                            <datalist id="editNodeTypeOptions">
                                <option value="Hardware">
                                <option value="Software">
                                <option value="Service">
                                <option value="Network">
                                <option value="Storage">
                                <option value="Database">
                                <option value="External">
                                <option value="API">
                                <option value="Cache">
                                <option value="Queue">
                                <option value="Monitor">
                                <option value="Security">
                            </datalist>
                        </div>
                        
                        <!-- Parent Node Select for Edit -->
                        <div class="config-field">
                            <label class="config-label">Parent Nodes</label>
                            <div class="parent-node-row">
                                <div id="editParentNodeContainer">
                                    <!-- Will be populated dynamically -->
                                </div>
                                <button class="add-parent-btn add-attribute-btn" type="button" onclick="addEditParentNodeSelect()">+</button>
                            </div>
                        </div>

                        <!-- Custom Attributes Section for Edit -->
                        <div class="custom-attributes">
                            <div class="attributes-header">
                                <span class="attributes-title">Custom Attributes</span>
                            </div>
                            <div id="editAttributesList">
                                <!-- Editable attributes will appear here -->
                            </div>
                            <button class="add-attribute-btn" onclick="addEditAttribute()">+</button>
                        </div>

                        <button class="save-node-btn" onclick="saveEditedNode()">Save Changes</button>
                        <button class="save-node-btn" onclick="deleteSelectedNode()" style="background: #dc3545; margin-top: 10px;">Delete Node</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-area">
            <!-- D3 Graph Visualization -->
            <div id="graph" class="d3-graph"></div>
            <svg></svg>
            <div class="tooltip" style="opacity:0"></div>
            <div class="canvas-grid"></div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Global state
        let currentMapData = null;
        let currentMapId = null;
        let simulation = null;

        // API Helper Functions
        async function apiCall(url, options = {}) {
            try {
                const response = await fetch(url, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'API call failed');
                }

                if (response.status === 204) {
                    return null; // No content
                }

                return await response.json();
            } catch (error) {
                console.error('API Error:', error);
                showMessage(error.message, 'error');
                throw error;
            }
        }

        function showMessage(message, type = 'success') {
            const messageEl = document.getElementById('statusMessage');
            messageEl.textContent = message;
            messageEl.className = `status-message ${type} show`;
            
            setTimeout(() => {
                messageEl.classList.remove('show');
            }, 3000);
        }

        // Map Management Functions
        async function loadMaps() {
            try {
                const maps = await apiCall('/api/maps');
                const selector = document.getElementById('mapSelector');
                
                selector.innerHTML = '<option value="">Select a map...</option>';
                
                maps.forEach(map => {
                    const option = document.createElement('option');
                    option.value = map.id;
                    option.textContent = `${map.name} (${map.nodeCount} nodes)`;
                    selector.appendChild(option);
                });

                // Load the first map if available
                if (maps.length > 0) {
                    selector.value = maps[0].id;
                    await loadSelectedMap();
                }
            } catch (error) {
                showMessage('Failed to load maps', 'error');
            }
        }

        async function loadSelectedMap() {
            const selector = document.getElementById('mapSelector');
            const mapId = selector.value;
            
            if (!mapId) {
                currentMapData = null;
                currentMapId = null;
                clearVisualization();
                return;
            }

            try {
                currentMapData = await apiCall(`/api/maps/${mapId}`);
                currentMapId = mapId;
                initVisualization();
                updateParentNodeOptions();
                updateEditNodeOptions();
                console.log('📊 Map loaded:', currentMapData.name);
            } catch (error) {
                showMessage('Failed to load map', 'error');
            }
        }

        async function createNewMap() {
            const name = prompt('Enter map name:');
            if (!name) return;

            try {
                const newMap = await apiCall('/api/maps', {
                    method: 'POST',
                    body: JSON.stringify({
                        name: name,
                        description: 'New system map'
                    })
                });

                await loadMaps();
                document.getElementById('mapSelector').value = newMap.id;
                await loadSelectedMap();
                showMessage('Map created successfully!');
            } catch (error) {
                showMessage('Failed to create map', 'error');
            }
        }

        async function deleteCurrentMap() {
            if (!currentMapId) {
                showMessage('No map selected', 'error');
                return;
            }

            if (!confirm(`Are you sure you want to delete "${currentMapData.name}"?`)) return;

            try {
                await apiCall(`/api/maps/${currentMapId}`, {
                    method: 'DELETE'
                });

                await loadMaps();
                showMessage('Map deleted successfully!');
            } catch (error) {
                showMessage('Failed to delete map', 'error');
            }
        }

        // D3.js Visualization
        function initVisualization() {
            clearVisualization();

            if (!currentMapData || !currentMapData.nodes) return;

            const width = window.innerWidth;
            const height = window.innerHeight;
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
            const tooltip = d3.select(".tooltip");

            const svg = d3.select("svg")
                .attr("viewBox", [0, 0, width, height]);

            const LXC = svg.append("g");

            svg.call(d3.zoom().on("zoom", ({transform}) => {
                LXC.attr("transform", transform);
            }));

            simulation = d3.forceSimulation(currentMapData.nodes)
                .force("link", d3.forceLink(currentMapData.links).id(d => d.id).distance(120))
                .force("charge", d3.forceManyBody().strength(-400))
                .force("center", d3.forceCenter(width / 2, height / 2));

            const link = LXC.append("g")
                .attr("stroke", "#aaa")
                .attr("stroke-opacity", 0.6)
                .selectAll("line")
                .data(currentMapData.links)
                .join("line")
                .attr("stroke-width", 1.5);

            const node = LXC.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll("circle")
                .data(currentMapData.nodes)
                .join("circle")
                .attr("r", 10)
                .attr("fill", d => colorScale(d.group))
                .call(drag(simulation))
                .on("mouseover", (event, d) => {
                    tooltip.transition().duration(200).style("opacity", 1);
                    let tooltipContent = `<strong>${d.id}</strong><br/>Group: ${d.group}`;
                    if (d.attributes && d.attributes.length > 0) {
                        tooltipContent += '<br/>Attributes:';
                        d.attributes.forEach(attr => {
                            tooltipContent += `<br/>${attr.name}: ${attr.value}`;
                        });
                    }
                    tooltip.html(tooltipContent)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY + 10) + "px");
                })
                .on("mouseout", () => {
                    tooltip.transition().duration(200).style("opacity", 0);
                });

            const label = LXC.append("g")
                .selectAll("text")
                .data(currentMapData.nodes)
                .join("text")
                .text(d => d.id)
                .attr("x", 12)
                .attr("y", "0.31em")
                .attr("fill", "#ccc")
                .style("font-size", "0.75rem");

            simulation.on("tick", () => {
                link.attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node.attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label.attr("x", d => d.x + 12)
                    .attr("y", d => d.y);
            });
        }

        function clearVisualization() {
            d3.select("svg").selectAll("*").remove();
        }

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        // Tool Functions
        function selectTool(tool) {
            // Remove active state from all items
            document.querySelectorAll('.tool-item').forEach(i => {
                i.style.background = '';
                i.style.borderColor = '';
            });

            const nodeConfig = document.getElementById('nodeConfig');
            const editNodeConfig = document.getElementById('editNodeConfig');

            // Toggle panels based on tool
            if (tool === 'node') {
                if (nodeConfig.classList.contains('active')) {
                    nodeConfig.classList.remove('active');
                    return;
                }
                nodeConfig.classList.add('active');
                editNodeConfig.classList.remove('active');
                updateParentNodeOptions();
            } else if (tool === 'edit') {
                if (editNodeConfig.classList.contains('active')) {
                    editNodeConfig.classList.remove('active');
                    return;
                }
                editNodeConfig.classList.add('active');
                nodeConfig.classList.remove('active');
                updateEditNodeOptions();
            }
            // Highlight the clicked tool
            event.target.closest('.tool-item').style.background = document.body.classList.contains('dark') ? '#333' : '#e3f2fd';
            event.target.closest('.tool-item').style.borderColor = document.body.classList.contains('dark') ? '#667eea' : '#667eea';
        }

        function updateParentNodeOptions() {
            const parentNodeSelects = document.querySelectorAll('.parent-node-select');
            parentNodeSelects.forEach(select => {
                select.innerHTML = '<option value="">Select parent node</option>';
                if (currentMapData && currentMapData.nodes) {
                    currentMapData.nodes.forEach(node => {
                        const option = document.createElement('option');
                        option.value = node.id;
                        option.textContent = node.id;
                        select.appendChild(option);
                    });
                }
            });
        }

        function updateEditNodeOptions() {
            const editNodeSelect = document.getElementById('editNodeSelect');
            if (editNodeSelect) {
                editNodeSelect.innerHTML = '<option value="">Select node</option>';
                if (currentMapData && currentMapData.nodes) {
                    currentMapData.nodes.forEach(node => {
                        const option = document.createElement('option');
                        option.value = node.id;
                        option.textContent = node.id;
                        editNodeSelect.appendChild(option);
                    });
                }
            }
        }

        // Node Management Functions
        async function saveNode() {
            if (!currentMapId) {
                showMessage('No map selected', 'error');
                return;
            }

            const parentNodeValues = Array.from(document.querySelectorAll('.parent-node-select'))
                .map(sel => sel.value)
                .filter(val => val);

            const nodeData = {
                id: document.getElementById('nodeName').value,
                group: document.getElementById('nodeType').value,
                parentNodes: parentNodeValues,
                attributes: []
            };

            // Collect custom attributes
            document.querySelectorAll('#attributesList .attribute-item').forEach(item => {
                const nameInput = item.querySelector('.attribute-name-input');
                const valueInput = item.querySelector('.attribute-value-input');
                if (nameInput.value && valueInput.value) {
                    nodeData.attributes.push({
                        name: nameInput.value,
                        value: valueInput.value
                    });
                }
            });

            if (!nodeData.id) {
                showMessage('Please enter a node name', 'error');
                return;
            }

            try {
                await apiCall(`/api/maps/${currentMapId}/nodes`, {
                    method: 'POST',
                    body: JSON.stringify(nodeData)
                });

                // Reload the map to get updated data
                await loadSelectedMap();

                // Clear form fields
                document.getElementById('nodeName').value = '';
                document.getElementById('nodeType').value = '';
                document.querySelectorAll('.parent-node-select').forEach(select => select.value = '');
                document.getElementById('attributesList').innerHTML = '';

                showMessage('Node added successfully!');
            } catch (error) {
                showMessage('Failed to add node', 'error');
            }
        }

        async function populateEditNodeForm() {
            const editNodeSelect = document.getElementById('editNodeSelect');
            const editNodeForm = document.getElementById('editNodeForm');
            const selectedId = editNodeSelect.value;
            
            if (!selectedId) {
                editNodeForm.style.display = 'none';
                return;
            }

            // Show the edit form
            editNodeForm.style.display = 'block';

            // Find the selected node
            const node = currentMapData.nodes.find(n => n.id === selectedId);
            if (!node) return;

            // Populate basic fields
            document.getElementById('editNodeName').value = node.id;
            document.getElementById('editNodeType').value = node.group || '';

            // Clear and populate parent nodes
            const editParentContainer = document.getElementById('editParentNodeContainer');
            editParentContainer.innerHTML = '';

            // Find current parent nodes
            const currentParents = currentMapData.links
                .filter(link => link.target === selectedId)
                .map(link => link.source);

            // Create parent node selects (at least one)
            if (currentParents.length === 0) {
                addEditParentNodeSelect();
            } else {
                currentParents.forEach((parentId, index) => {
                    addEditParentNodeSelect(parentId);
                });
            }

            // Clear and populate custom attributes
            const editAttributesList = document.getElementById('editAttributesList');
            editAttributesList.innerHTML = '';
            
            (node.attributes || []).forEach(attr => {
                addEditAttribute(attr.name, attr.value);
            });
        }

        function addEditParentNodeSelect(selectedParentId = '') {
            const container = document.getElementById('editParentNodeContainer');
            
            const rowDiv = document.createElement('div');
            rowDiv.className = 'parent-node-select-row';

            const select = document.createElement('select');
            select.className = 'config-select edit-parent-node-select';
            select.innerHTML = '<option value="">Select parent node</option>';
            
            if (currentMapData && currentMapData.nodes) {
                // Don't include the currently edited node as a parent option
                const editNodeSelect = document.getElementById('editNodeSelect');
                const currentEditId = editNodeSelect.value;
                
                currentMapData.nodes.forEach(node => {
                    if (node.id !== currentEditId) {
                        const option = document.createElement('option');
                        option.value = node.id;
                        option.textContent = node.id;
                        if (node.id === selectedParentId) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    }
                });
            }

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-parent-btn';
            removeBtn.textContent = '−';
            removeBtn.onclick = function() {
                rowDiv.remove();
                updateEditRemoveParentButtons();
            };

            rowDiv.appendChild(select);
            rowDiv.appendChild(removeBtn);
            container.appendChild(rowDiv);
            
            updateEditRemoveParentButtons();
        }

        function updateEditRemoveParentButtons() {
            const container = document.getElementById('editParentNodeContainer');
            const rows = container.querySelectorAll('.parent-node-select-row');
            rows.forEach((row, idx) => {
                const btn = row.querySelector('.remove-parent-btn');
                if (btn) btn.style.display = idx === 0 ? 'none' : '';
            });
        }

        async function saveEditedNode() {
            const editNodeSelect = document.getElementById('editNodeSelect');
            const originalNodeId = editNodeSelect.value;
            if (!originalNodeId) {
                showMessage('Please select a node to edit', 'error');
                return;
            }

            try {
                // Get updated values
                const newNodeName = document.getElementById('editNodeName').value;
                const newNodeType = document.getElementById('editNodeType').value;

                // Collect parent nodes
                const newParentNodes = Array.from(document.querySelectorAll('.edit-parent-node-select'))
                    .map(select => select.value)
                    .filter(value => value);

                // Collect attributes
                const attributes = [];
                document.getElementById('editAttributesList').querySelectorAll('.attribute-item').forEach(item => {
                    const nameInput = item.querySelector('.attribute-name-input');
                    const valueInput = item.querySelector('.attribute-value-input');
                    if (nameInput.value && valueInput.value) {
                        attributes.push({
                            name: nameInput.value,
                            value: valueInput.value
                        });
                    }
                });

                if (!newNodeName) {
                    showMessage('Please enter a node name', 'error');
                    return;
                }

                // Debug logging
                console.log('🔧 Editing node:', originalNodeId);
                console.log('🔧 New name:', newNodeName);
                console.log('🔧 New type:', newNodeType);
                console.log('🔧 New parent nodes:', newParentNodes);
                console.log('🔧 New attributes:', attributes);

                // Check if name changed and if new name already exists
                if (newNodeName !== originalNodeId) {
                    const nameExists = currentMapData.nodes.find(n => n.id === newNodeName && n.id !== originalNodeId);
                    if (nameExists) {
                        showMessage('A node with this name already exists', 'error');
                        return;
                    }

                    console.log('🔄 Node name changed, will delete and recreate');
                    // If name changed, delete old and create new
                    await apiCall(`/api/maps/${currentMapId}/nodes/${originalNodeId}`, {
                        method: 'DELETE'
                    });

                    await apiCall(`/api/maps/${currentMapId}/nodes`, {
                        method: 'POST',
                        body: JSON.stringify({
                            id: newNodeName,
                            group: newNodeType || 'Default',
                            attributes: attributes,
                            parentNodes: newParentNodes
                        })
                    });
                } else {
                    console.log('📝 Node name unchanged, updating in place');
                    // Just update the existing node
                    const updateData = {
                        id: newNodeName,
                        group: newNodeType || 'Default',
                        attributes: attributes,
                        parentNodes: newParentNodes
                    };
                    
                    console.log('📤 Sending update data:', updateData);
                    
                    await apiCall(`/api/maps/${currentMapId}/nodes/${originalNodeId}`, {
                        method: 'PUT',
                        body: JSON.stringify(updateData)
                    });
                }

                console.log('✅ Node update completed, reloading map');
                await loadSelectedMap();
                updateEditNodeOptions();
                
                // Reselect the node (with potentially new name)
                document.getElementById('editNodeSelect').value = newNodeName;
                populateEditNodeForm();
                
                showMessage('Node updated successfully!');
            } catch (error) {
                console.error('❌ Error in saveEditedNode:', error);
                showMessage('Failed to update node', 'error');
            }
        }

        async function deleteSelectedNode() {
            const editNodeSelect = document.getElementById('editNodeSelect');
            const selectedId = editNodeSelect.value;
            if (!selectedId) {
                showMessage('Please select a node to delete', 'error');
                return;
            }

            if (!confirm(`Are you sure you want to delete the node "${selectedId}"?`)) return;

            try {
                await apiCall(`/api/maps/${currentMapId}/nodes/${selectedId}`, {
                    method: 'DELETE'
                });

                await loadSelectedMap();
                editNodeSelect.value = '';
                document.getElementById('editAttributesList').innerHTML = '';
                showMessage('Node deleted successfully!');
            } catch (error) {
                showMessage('Failed to delete node', 'error');
            }
        }

        // All your existing functions remain the same
        function addAttribute() {
            const attributesList = document.getElementById('attributesList');

            const attributeDiv = document.createElement('div');
            attributeDiv.className = 'attribute-item';

            const nameRow = document.createElement('div');
            nameRow.className = 'attribute-name-row';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'attribute-name-input';
            nameInput.placeholder = 'Attribute name';

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-attribute-btn';
            removeBtn.textContent = '−';
            removeBtn.onclick = function() {
                attributeDiv.remove();
            };

            nameRow.appendChild(nameInput);
            nameRow.appendChild(removeBtn);

            const valueInput = document.createElement('textarea');
            valueInput.className = 'attribute-value-input';
            valueInput.placeholder = 'Enter attribute value (can be multiple lines)';

            attributeDiv.appendChild(nameRow);
            attributeDiv.appendChild(valueInput);

            attributesList.appendChild(attributeDiv);
        }

        function addEditAttribute(name = '', value = '') {
            const editAttributesList = document.getElementById('editAttributesList');

            const attributeDiv = document.createElement('div');
            attributeDiv.className = 'attribute-item';

            const nameRow = document.createElement('div');
            nameRow.className = 'attribute-name-row';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'attribute-name-input';
            nameInput.placeholder = 'Attribute name';
            nameInput.value = name;

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-attribute-btn';
            removeBtn.textContent = '−';
            removeBtn.onclick = function() {
                attributeDiv.remove();
            };

            nameRow.appendChild(nameInput);
            nameRow.appendChild(removeBtn);

            const valueInput = document.createElement('textarea');
            valueInput.className = 'attribute-value-input';
            valueInput.placeholder = 'Enter attribute value';
            valueInput.value = value;

            attributeDiv.appendChild(nameRow);
            attributeDiv.appendChild(valueInput);

            editAttributesList.appendChild(attributeDiv);
        }

        function addParentNodeSelect() {
            const container = document.getElementById('parentNodeContainer');
            const selects = container.querySelectorAll('.parent-node-select');
            const newSelect = selects[0].cloneNode(true);
            newSelect.selectedIndex = 0;

            const rowDiv = document.createElement('div');
            rowDiv.className = 'parent-node-select-row';
            rowDiv.appendChild(newSelect);

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-parent-btn';
            removeBtn.textContent = '−';
            removeBtn.onclick = function() {
                rowDiv.remove();
                updateRemoveParentButtons();
            };
            rowDiv.appendChild(removeBtn);

            container.appendChild(rowDiv);
            updateRemoveParentButtons();
        }

        function updateRemoveParentButtons() {
            const container = document.getElementById('parentNodeContainer');
            const rows = container.querySelectorAll('.parent-node-select-row');
            rows.forEach((row, idx) => {
                const btn = row.querySelector('.remove-parent-btn');
                if (btn) btn.style.display = idx === 0 ? 'none' : '';
            });
        }

        function exportMap() {
            if (!currentMapData) {
                showMessage('No map selected', 'error');
                return;
            }

            const dataStr = JSON.stringify(currentMapData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${currentMapData.name}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showMessage('Map exported successfully!');
        }

        function shareMap() {
            const shareUrl = window.location.href;
            navigator.clipboard.writeText(shareUrl).then(() => {
                showMessage('Share URL copied to clipboard!');
            }).catch(() => {
                showMessage(`Share this URL: ${shareUrl}`);
            });
        }

        function saveMap() {
            showMessage('Map saved automatically!');
        }

        function toggleTheme() {
            document.body.classList.toggle('dark');
            const btn = document.querySelector('.theme-toggle');
            btn.innerHTML = document.body.classList.contains('dark') ? '☀️' : '🌙';
        }

        function togglePanel() {
            const panel = document.getElementById('sidePanel');
            const collapseBtn = panel.querySelector('.collapse-btn');
            
            panel.classList.toggle('collapsed');
            collapseBtn.innerHTML = panel.classList.contains('collapsed') ? '‹' : '‹';
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', async () => {
            await loadMaps();
            
            // Initialize parent node container
            const container = document.getElementById('parentNodeContainer');
            const firstSelect = container.querySelector('.parent-node-select');
            if (firstSelect && !firstSelect.parentElement.classList.contains('parent-node-select-row')) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'parent-node-select-row';
                rowDiv.appendChild(firstSelect);
                container.appendChild(rowDiv);
            }
            updateRemoveParentButtons();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (currentMapData) {
                setTimeout(initVisualization, 100);
            }
        });
    </script>
</body>
</html>